<!doctype html>
<html class="docs-version-current" lang="de" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<link rel="search" type="application/opensearchdescription+xml" title="Rule The Bots" href="/opensearch.xml">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Motorencoder zur Bestimmung des Fahrtweges | Rule The Bots</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://spacehal.github.io/docs/robotik/wheelEncoder"><meta data-react-helmet="true" name="docsearch:language" content="de"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Motorencoder zur Bestimmung des Fahrtweges | Rule The Bots"><meta data-react-helmet="true" name="description" content="Mit Hilfe der Rad-Encoder wird der Roboter geradeaus fahren und seine Geschwindigkeit regeln. Zum Regeln der Geschwindikeit wird ein Integral-Regler verwendet."><meta data-react-helmet="true" property="og:description" content="Mit Hilfe der Rad-Encoder wird der Roboter geradeaus fahren und seine Geschwindigkeit regeln. Zum Regeln der Geschwindikeit wird ein Integral-Regler verwendet."><meta data-react-helmet="true" name="keywords" content="Arduino,Roboter,Robotik,Odometrie,Quadraturencoder,Inkrementalgeber,Positionsbestimmung,Radencoder,Motorencoder,geradeaus fahren,Zumo 32u4"><link data-react-helmet="true" rel="icon" href="/img/LogoSmallRed.svg"><link data-react-helmet="true" rel="canonical" href="https://spacehal.github.io/docs/robotik/wheelEncoder"><link data-react-helmet="true" rel="alternate" href="https://spacehal.github.io/docs/robotik/wheelEncoder" hreflang="de"><link data-react-helmet="true" rel="alternate" href="https://spacehal.github.io/docs/robotik/wheelEncoder" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.d1942bf1.css">
<link rel="preload" href="/assets/js/runtime~main.7427cd70.js" as="script">
<link rel="preload" href="/assets/js/main.71b590ca.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Zum Hauptinhalt springen</a></div><nav class="navbar navbar--fixed-top navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/LogoSmallRed.svg" alt="Rule the Bots" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/LogoSmallRed.svg" alt="Rule the Bots" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">RuleTheBots</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/arduino/helloworld">Arduino</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/robotik/beginning">Robotik</a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/zumo32u4/gettingStarted">Zumo32u4</a><a class="navbar__item navbar__link" href="/docs/more/links">Links</a><div class="searchBox_1Kl_"><button type="button" class="DocSearch DocSearch-Button" aria-label="Suche"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Suche</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Zurück nach oben scrollen" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo sidebarWithHideableNavbar_267A"><a tabindex="-1" class="sidebarLogo_3h0W" href="/"><img src="/img/LogoSmallRed.svg" alt="Rule the Bots" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/LogoSmallRed.svg" alt="Rule the Bots" class="themedImage_1VuW themedImage--dark_hz6m"><b>RuleTheBots</b></a><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_2fq0" href="/docs/robotik/beginning">Robotik</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" tabindex="0" href="/docs/robotik/beginning">Linienfolger</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_2fq0" tabindex="0" href="/docs/robotik/wheelEncoder">Motorencoder</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/robotik/wheelEncoder">Motorencoder</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/robotik/goStraight">Ge­ra­de­aus­fahrt</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/robotik/speedControl">Geschwindigkeitsregler</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/robotik/botBarcode">Anwendung: Barcode</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" tabindex="0" href="/docs/robotik/odometrie">Navigation und Lokalisierung</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" tabindex="0" href="/docs/robotik/objektFinden">Hinderniserkennung</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" tabindex="0" href="/docs/robotik/gridNavigation">Gitter</a></div></li></ul></li></ul></nav><button type="button" title="Seitenleiste einklappen" aria-label="Seitenleiste einklappen" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">Auf dieser Seite</button></div><div class="theme-doc-markdown markdown"><header><h1>Motorencoder zur Bestimmung des Fahrtweges</h1></header><h2 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="inkrementalgeber-incremental-encoder">Inkrementalgeber (<em>Incremental Encoder</em>)<a class="hash-link" href="#inkrementalgeber-incremental-encoder" title="Direkter Link zur Überschrift">​</a></h2><p>Eine der ersten Aufgaben für den <a href="/docs/robotik/beginning">selbstgebauten Roboter</a> war es, den Roboter eine Strecke von 1,5 Meter fahren zu lassen. Die Lösung konnte nur durch Probieren von unterschiedliche langen Fahrzeit ermittelt werden. Was dem selbstgebauten Roboter fehlte, war die Möglichkeit den zurückgelegten Fahrtweg zu messen.</p><p>Sind die Motoren (oder Räder) mit einem <a href="https://de.wikipedia.org/wiki/Inkrementalgeber" target="_blank" rel="noopener noreferrer">Inkrementalgeber</a> (Radencoder) ausgestattet, kann mit diesen bestimmt werden, wie weit sich die einzelnen Motoren zwischen zwei Messungen gedreht haben. Dadurch wird es möglich sowohl die <a href="/docs/robotik/speedControl">Geschwindigkeit</a> auch als die gefahrene Strecke oder auch die aktuelle <a href="/docs/robotik/odometrie">Position</a> des Roboters zu bestimmen</p><p>Der Zumo 32u4 hat an jedem Motor einen <a href="https://www.pololu.com/docs/0J63/3.4" target="_blank" rel="noopener noreferrer">Quadratur-Encoder</a>, welcher mit einer magnetischen Scheibe pro Motorwelle und zwei <a href="https://www.leifiphysik.de/elektrizitaetslehre/bewegte-ladungen-feldern/grundwissen/hall-effekt" target="_blank" rel="noopener noreferrer">Hall-Effekt</a>-Sensoren für jeden Motor realisiert ist. Der Quadratur-Encoder hat eine Auflösung von 12 Schritten pro Umdrehung.</p><p>Da die Räder nicht direkt, sondern mit einem Getriebe  mit der Motorwelle verbunden sind (Übersetzung 75.81:1), führt das zu einer Auflösung von <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn><mo>×</mo><mn>75.81</mn><mo>≈</mo><mn>909</mn><mo separator="true">,</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">12\times 75.81 \approx 909,7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">7</span><span class="mord">5</span><span class="mord">.</span><span class="mord">8</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em"></span><span class="mord">9</span><span class="mord">0</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord">7</span></span></span></span></span> Impulsen pro Umdrehung (CPR - counts per revolution).</p><img src="/img/robotik/RadEncoder.png" alt="Ein Radencoder für die Odometrie" width="450px" class="center"><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="quadratur-encoder-quadrature-encoder">Quadratur-Encoder (<em>Quadrature Encoder</em>)<a class="hash-link" href="#quadratur-encoder-quadrature-encoder" title="Direkter Link zur Überschrift">​</a></h3><p>Der oben dargestellte Rad-Encoder ist ein sehr einfacher Inkrementalgeber. Was diesem Encoder fehlt, ist die Möglichkeit die Drehrichtung des Rades zu bestimmen. Ein Quadratur-Encoder schafft hier Abhilfe. </p><p>Bei einem Quadratur-Encoder wird das Rad nicht mit einem Sensor, sondern mit <strong>zwei räumlich versetzten Sensoren</strong> abgetastet. Dadurch ergibt sich nicht nur eine Impulsfolge, welche angibt, wie weit sich das Rad gedreht hat, sondern <strong>zwei Impulsfolgen (A und B)</strong> aus welchen zusätzlich auch die Drehrichtung bestimmt werden kann. </p><h4 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="drehrichtung-im-uhrzeigersinn">Drehrichtung im Uhrzeigersinn<a class="hash-link" href="#drehrichtung-im-uhrzeigersinn" title="Direkter Link zur Überschrift">​</a></h4><p>In der dargestellten Abbilung sind die beiden Encoder-Sensoren mit den Buchstaben A und B bezeichnet. Der rechte Sensor (A) ist bei einer Drehung im <strong>Uhrzeigersinn</strong> der Sensor, welcher zuerst die Zustandsänderungen (von 0 auf 1 oder andersrum) detektiert. Der Sensor B wird die selbe Zustandsänderung kurz danach detektieren. Das bedeutet, dass direkt nach dem Zustandswechsel des Sensors A, der Sensor B noch im alten Zustand ist. </p><p>Bei einer <strong>Drehung im Uhrzeigersinn</strong> gilt bei der Zustandsänderung des Sensors A: <code>B=!A</code>.</p><img src="/img/robotik/QuadEncoderClockwise.png" alt="Quadratur Encoder" width="470px" class="center"><h4 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="drehrichtung-entgegen-dem-uhrzeigersinn">Drehrichtung entgegen dem Uhrzeigersinn<a class="hash-link" href="#drehrichtung-entgegen-dem-uhrzeigersinn" title="Direkter Link zur Überschrift">​</a></h4><p>Dreht sich das Rad entgegen dem Uhrzeigersinn ist der Sensor B der führende Sensor und erkennt die Zustandsänderung als erstes. Aus Sicht des Sensors A bedeutet das, dass der Sensor A bei einer Zustandsänderung den bereits detektierten Zustand vom Sensor B annimmt.</p><p>Bei einer <strong>Drehung entgegen dem Uhrzeigersinn</strong> gilt bei der Zustandsänderung des Sensors A: <code>B=A</code>.</p><img src="/img/robotik/QuadEncoderCC.png" alt="Quadratur Encoder" width="470" class="center"><h2 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="auslesen-der-rad-encoder-beim-zumo-32u4">Auslesen der Rad-Encoder beim Zumo 32u4<a class="hash-link" href="#auslesen-der-rad-encoder-beim-zumo-32u4" title="Direkter Link zur Überschrift">​</a></h2><p>In der Zumo32u4-Bibliothek wird die Klasse <code>Zumo32U4Encoders</code> bereitgestellt, welche es mit den Methode <code>getCountsLeft()</code> und <code>getCountsRight()</code> ermöglicht, die vom Encoder gemessenen Impulse auszugeben. </p><p>Die Methoden zum Auslesen der Rad-Encoder verwenden im Hintergrund so genannte <a href="https://de.wikipedia.org/wiki/Interrupt" target="_blank" rel="noopener noreferrer">Interrupt-Funktionen</a>, welches jedesmal, wenn die Encoder einen Impuls erhalten, eine globale Variable im eins erhöhen oder verringern (abhängig von der Drehrichtung). Die Methoden <code>getCountsLeft()</code> und <code>getCountsRight()</code> geben dann die aktuelle Anzahl der aufsummierten Impulse pro Rad an.</p><p>Die Methoden <code>getCountsAndResetLeft()</code> und <code>getCountsAndResetRight()</code> verhalten sich wie die anderen beiden Funktionen, setzten jedoch die entsprechende globale Variable für die aufsummierten Impulse zurück.</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</h5></div><div class="admonition-content"><p>Damit die globalen Zähler für die Encoder-Impulse nicht überlaufen, sollten regelmäßig die Funktionen <code>getCountsAndResetLeft()</code> und <code>getCountsAndResetRight()</code> aufgerufen werden.</p></div></div><div class="codeBlockContainer_K1bP language-arduino theme-code-block"><div class="codeBlockContent_hGly arduino"><pre tabindex="0" class="prism-code language-arduino codeBlock_23N8 thin-scrollbar" style="background-color:#282c34;color:#ffffff"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#ffffff"><span class="token plain">// Anzeigen der Encoder-Werte auf dem Display </span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">#include &lt;Wire.h&gt;</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">#include &lt;Zumo32U4.h&gt;</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">Zumo32U4Encoders encoders;                       //  Encoder-Objekt deklarieren</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">Zumo32U4LCD lcd;</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">unsigned long lastDisplayTime = 0;</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">void setup() {</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">                                                // bleibt leer</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">}</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">void loop() {</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">  if ((millis() - lastDisplayTime) &gt; 100) {</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">    int countsLeft = encoders.getCountsLeft();   // Auslesen des globalen Impuls-Zählers</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">    int countsRight = encoders.getCountsRight(); // Die Impulse werden im Hintergrund gezählt</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">    lcd.clear();</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">    lcd.print(countsLeft);</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">    lcd.gotoXY(0, 1);</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">    lcd.print(countsRight);</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">    </span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">    lastDisplayTime = millis();</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#ffffff"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="In die Zwischenablage kopieren" class="copyButton_Ue-o clean-btn">Kopieren</button></div></div><details class="details_2Ziz alert alert--info details_1VDD ueben" data-collapsed="true"><summary>Aufgaben</summary><div><div class="collapsibleContent_3OHp"> <ol><li>Die Radencoder haben eine Auflösung von 909,7 Impulsen pro Rad-Umdrehung. Bestimmen Sie rechnerisch, wie weit der zurückgelegte Weg zwischen zwei Encoder-Impulsen ist (Millimeter pro Impuls).
<em>Hinweis: Messen Sie den Durchmesser der Räder.</em></li><li>Messen Sie die Anzahl der Encoder-Impulse die benötigt werden, um eine Strecke von exakt 20 cm zurückzulegen. Bestimmen Sie hieraus die Encoder-Auflösung (in Millimeter pro Impulse).</li><li>Schreiben Sie ein Programm, welches den Roboter mit Hilfe der Rad-Encoder <strong>exakt</strong> 20 cm weit fahren lässt. Geben Sie auf dem Display die gefahrene Strecke in Millimetern an. Vergleichen Sie Ihr Ergebnis mit der Aufgabe 2. (Die zurückgelegt Strecke sollte als Mittelwert aus den beiden Rad-Encodern berechnet werden.)</li><li>Wiederholen Sie die letzte Aufgabe. Versuchen Sie jedoch den Roboter die 20 cm so schnell wie möglich zurücklegen zu lassen. Messen Sie die Zeit. (<em>Hinweis: Nutzen Sie einen geeigneten Regler</em>)</li></ol></div></div></details></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"></div><div class="col lastUpdated_13-_"><span class="theme-last-updated">Letztes Update<!-- --> am <b><time datetime="2022-01-02T10:28:53.000Z">2.1.2022</time></b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Dokumentation Seiten Navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/robotik/advancedLine"><div class="pagination-nav__sublabel">Zurück</div><div class="pagination-nav__label">Linie mit Kreuzungen</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/robotik/goStraight"><div class="pagination-nav__sublabel">Weiter</div><div class="pagination-nav__label">Ge­ra­de­aus­fahrt</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#inkrementalgeber-incremental-encoder" class="table-of-contents__link toc-highlight">Inkrementalgeber (<em>Incremental Encoder</em>)</a><ul><li><a href="#quadratur-encoder-quadrature-encoder" class="table-of-contents__link toc-highlight">Quadratur-Encoder (<em>Quadrature Encoder</em>)</a></li></ul></li><li><a href="#auslesen-der-rad-encoder-beim-zumo-32u4" class="table-of-contents__link toc-highlight">Auslesen der Rad-Encoder beim Zumo 32u4</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/SpaceHal/spacehal.github.io/discussions" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Forum<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Schule</div><ul class="footer__items"><li class="footer__item"><a href="https://www.osztiem.de/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>OSZTIEM<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://www.arduino.cc/reference/de/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Arduino<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a class="footer__link-item" href="/docs/impressum">Impressum</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Stefan Warm. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.7427cd70.js"></script>
<script src="/assets/js/main.71b590ca.js"></script>
</body>
</html>